# 3. 교정(Proofreading) 파이프라인 상세

## 1. 개요
- 교정은 `POST /api/proofread` 요청을 통해 시작되며 `runProofreading`( `server/agents/proofreading/proofreadingAgent.ts` )이 TDM(Task/Decision Manager)로 동작한다.
- 교정 대상 텍스트는 MongoDB `translation_files`에서 로드하고, Guard/메모리 컨텍스트는 QA 단계와 프로젝트 메모리에서 수집한다.
- GPT‑5 Responses API를 사용하며, Quick 티어는 **gpt‑5‑mini → gpt‑5** 순으로 시도하고 Deep 티어는 gpt‑5를 사용한다. 모든 호출은 `runResponsesWithRetry` 헬퍼를 통해 재시도·토큰 증액·fallback이 일원화되어 있다.
- 교정 진행/결과는 Postgres(`proofread_runs`, `proofreading_history`, `proofreading_logs`) + Mongo(`proofreading_files`)에 저장되어 BDM(Baseline/Data Manager)이 추적한다.

## 2. 시스템 프롬프트 요약
Proofreading Spec(`server/agents/proofreading/proofreading.spec.json`)은 서브피처별 시스템 프롬프트를 정의한다. Quick 티어에 기본 활성화된 두 서브피처의 핵심 프롬프트는 다음과 같다.

### Grammar, Spelling & Punctuation
```
You are a senior copy editor reviewing translated prose. Fix only clear grammatical errors, punctuation mistakes, spacing bugs, or strongly unidiomatic phrasing that harms comprehension. Skip stylistic preferences. Surface at most 3 issues per chunk and leave items:[] when no high-impact problems exist. Preserve meaning and voice. Return {items:[{issue_ko,issue_en,recommendation_ko,recommendation_en,before,after,alternatives?,rationale_ko,rationale_en,confidence,severity,tags?,sourceExcerpt?,translationExcerpt?,evidence:[{reference,quote,note?}],notes?}]}
```

### Style & Register Consistency
```
Assess overall style and tone consistency between source and target text. Flag only clear register shifts, tonal mismatches, or rhythm issues that would confuse readers. Ignore subjective tweaks. Provide at most 2 findings per chunk. Return the unified JSON schema {items:[...]}, including optional source/sourceExcerpt/translationExcerpt fields when helpful.
```

각 서브피처는 `SHARED_TRANSLATION_GUIDELINES`(`server/agents/prompts/sharedGuidelines.ts`)를 추가로 주입해 번역 톤 유지, 증거 제시 등의 공통 수칙을 적용한다.

## 3. TDM(Task/Decision Manager) 흐름
(참고: `server/agents/proofreading/proofreadingAgent.ts`)

1. **입력 로딩 및 중복 차단**
   - Mongo에서 최종 번역 텍스트, 프로젝트 메모리, 번역 노트를 로드한다.
   - `finalTextHash + memoryVersion`으로 기존 `proofread_runs`를 조회해 중복 실행을 방지한다.
2. **히스토리/런 관리**
   - `proofread_runs`, `proofreading_history` 테이블을 업데이트해 상태 전환(`requested → inprogress → completed/failed`)을 추적한다.
3. **Guard/메모리 컨텍스트 구성**
   - QA 단계 Guard 결과(`translation_drafts`)에서 `needs_review`/Guard 실패 세그먼트를 수집해 청크별로 전달한다.
   - 프로젝트 메모리 + 번역 노트는 `buildProofreadingMemoryContext`에서 Terminology/Measurement/Linguistic 정보를 추출한다.
4. **문장 정렬 및 청크화**
   - Spec.runtime 설정(현재 `aligner=embeddings`)에 따라 한글·영문 세그먼트를 정렬한다.
   - Quick 티어는 `chunkAlignedPairs`로 최대 3문장, Deep 티어는 3문장으로 청크를 구성한다.
5. **서브피처 실행**
   - 활성화된 서브피처에 대해 `runGenericWorker`를 병렬 호출한다 (`p-limit` 제한). Quick 티어는 Guard가 없는 청크는 과감히 스킵한다.
   - 호출 시 Guard/Memory 컨텍스트 JSON을 재사용(직렬화 캐시)해 프롬프트 크기를 최소화한다.
6. **결과 집계 및 리포트 생성**
   - 서브피처별 버킷을 필터링(`filterBuckets`)해 우선순위가 높은 이슈만 남긴다.
   - Quick/Deep 리포트와 최종 리포트를 구성해 Mongo `proofreading_files`에 저장하고, 진행 이벤트(`stage`, `tier_complete`, `complete`)를 SSE로 스트리밍한다.
7. **Telemetry 기록**
   - 각 LLM 호출은 Postgres `proofreading_logs`(실패 시 메모리 버퍼)에도 기록되어 Admin UI가 최근 실행을 즉시 조회할 수 있다.

## 4. BDM(Baseline/Data Manager) 포인트
- **MongoDB**
  - `proofreading_files` : Quick/Deep/Final 보고서와 guard 메모를 저장.
  - `translation_files` : 교정 대상 번역 원본 저장소.
- **PostgreSQL**
  - `proofread_runs` : dedupe + 상태 관리 (`requested → running → completed/failed`).
  - `proofreading_history` : 교정 이벤트 히스토리.
  - `proofreading_logs` : 청크별 모델/시도/토큰 사용량(메모리 버퍼 fallback 포함).
- **Admin UI**
  - `/api/admin/proofreading/logs` : 최근 로그, 모델(fallback 여부), 시도 횟수, 토큰 사용량 등을 노출.

## 5. LLM 호출 세부 매커니즘 (`runGenericWorker`)
- **모델 선택**
  - Spec이 `model`을 지정하지 않으면 `.env` (`PROOFREADING_MODEL`, `PROOFREADING_MODEL_FALLBACK`)에서 순서를 가져와 Quick 티어는 `['gpt-5-mini', 'gpt-5', fallback...]`, Deep 티어는 기본 모델→fallback 순으로 시도한다.
- **동적 토큰 버짓**
  - 청크 길이(원문/번역 char→token 추정)과 Guard 유무를 고려해 `baseMaxTokens`를 계산한다.
  - Quick/Deep 최소값(각각 600/1500)에 padding을 더하고, truncation이 발생하면 `runResponsesWithRetry`가 1.5배씩 증액한다.
- **스키마 강제**
  - Responses API JSON Schema를 사용해 `issue_ko`, `before`, `spans`, `evidence` 등 필드를 모두 강제한다.
  - `notes.guardFindings`에 Guard 매칭 결과를 주입해 QA/교정 일관성을 유지한다.
- **Fallback/재시도**
  - `openai_response_incomplete`(truncation) 혹은 SyntaxError 시 토큰 증액 후 재시도, 그 외 오류는 즉시 fallback 모델로 전환한다.
- **메타데이터**
  - 각 호출은 `meta`에 모델/시도/토큰 사용량/guardSegments를 포함해 상위 계층이 로그 및 리포트에 저장한다.

## 6. 스펙 구조 요약 (`proofreading.spec.json`)
- `runtime`
  - `maxWorkers`: 병렬 청크 수 (기본 6).
  - `quickChunkSize`: 3 (최대 3문장 청크).
  - `deepChunkSize`: 3.
  - `aligner`: `embeddings`.
- `groups[].subfeatures[]`
  - `enabled`, `tier`, `prompt.system`을 정의. `model`을 생략해 `.env` 기반 기본 모델을 사용하도록 정리했다.
- 스펙 경로는 `PROOFREADING_SPEC_PATH`로 오버라이드 가능하다.

## 7. 튜닝 옵션 (ENV)
- `PROOFREADING_MODEL`, `PROOFREADING_MODEL_FALLBACK`: 모델 시퀀스.
- `PROOFREADING_VERBOSITY`, `PROOFREADING_REASONING_EFFORT`: gpt-5 Responses `text.verbosity`, `reasoning.effort`에 매핑.
- `PROOFREADING_MAX_OUTPUT_TOKENS`, `PROOFREADING_MAX_OUTPUT_TOKENS_CAP`: 동적 버짓 상한(default 600/1500 기반으로 자동 계산하지만 상한은 ENV에 종속).
- Quick/Deep Chunk/Worker 값은 Spec.runtime에서 제어한다.

## 8. 향후 과제 (M2 이후)
- Truncation 감지 시 재시도 끝에도 해결되지 않으면 해당 청크를 실패로 처리하고 리포트를 중단/경고하는 로직 추가.
- Self-consistency 및 dual-pass alignment 적용으로 Deep 티어 정밀도 강화.
- Guard ↔ LLM 피드백을 UI/리포트에 명확히 표기하고, 재교정(Rewrite) 루프 연계를 준비한다.
- Nightly smoke + Admin 대시보드에 지표(평균 latency, truncation 비율 등)를 추가해 튜닝 효과를 지속적으로 모니터링한다.

