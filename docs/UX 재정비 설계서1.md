# UX 재정비 설계서 1

## 문서 목적
- 교정 요약 카드, 사이드바 정보 구조, 빠른 액션 루프 등에서 관측된 UX 결함을 일괄 정비한다.
- Codex가 이 설계서만으로 구현을 진행할 수 있도록 UX·아키텍처·엔지니어링 관점의 체크리스트를 명시한다.
- 채팅 카드 수를 최소화하고, 사용자가 겁먹지 않는 부드러운 톤·짧은 문장을 유지하기 위한 가이드라인을 포함한다.
- QA 및 배포 이전에 제품/디자인팀과 공유해 사전 검토를 마칠 수 있게 한다.

## 핵심 원칙
- **카드 최소화:** Recap/스테이지 카드는 각 영역당 최대 1장만 유지하며, 상태 변경 시 덮어쓰기(Update in place)한다.
- **짧은 문장:** 챗봇 메시지는 2~3문장, CTA는 1줄 설명을 넘지 않도록 한다. 토글/팝오버를 활용해 세부사항은 숨긴다.
- **친근한 톤:** 모든 텍스트는 사용자의 UI 언어에 맞춰 부드럽고 위로하는 표현을 사용한다. “~해주세요”보다 “같이 해볼까요?” 식의 어조 권장.
- **즉시 조치:** 모든 메시지는 명확한 다음 행동을 포함하거나, 아무 행동이 필요 없다면 축약된 확인 메시지로 대체한다.
- **중복 금지:** 타임라인, 사이드바, 챗봇에서 동일 콘텐츠가 반복되지 않도록 데이터 공급원을 하나로 묶는다.

## 개선 항목 개요
| 번호 | 주제 | 목표 |
| --- | --- | --- |
| 1 | 교정 요약 파이프라인 재설계 | 교정 recap 카드와 Proofread 단계 카드가 동일한 상태를 반영하고, 진행률/완료 CTA를 제공한다. |
| 2 | 사이드바 정보 구조 개편 | 상단 헤더 부담을 줄이고, 상태/액션/타임라인을 좌측에 명확하게 배치한다. |
| 3 | 온보딩 & 빠른 액션 루프 정비 | 핵심 빠른 액션을 유지하면서 중복 안내를 줄이고, 초보자 흐름을 안정화한다. |
| 4 | 타임라인·채팅 노이즈 축소 | 자동 상태 메시지를 재구성하여 중복 알림을 제거한다. |
| 5 | Proofread 후속 질문 대응 | LLM 보조 전에 규칙 기반 요약을 준비해 톤과 언어 일관성을 유지한다. |
| 6 | Ebook 의도 후속 안내 | 패널 여는 데서 끝나지 않고 상태 + 다음 단계 메시지를 제공한다. |

---

## 1. 교정 요약 파이프라인 재설계

### 범위 및 배경
- 현행 `ProofreadIssuesContext`는 새로운 이슈가 추가될 때만 recap insight를 push한다. 이로 인해 진행률/완료 상태가 갱신되지 않는다.
- `ChatOrchestrator`의 Proofread 단계 카드가 recap 요약과 별도로 동작해 사용자에게 상반된 메시지를 전달한다.

### UX 관점 확인 사항
- Recap 카드는 항상 **1장**만 존재하며, 상태 변화 시 문구·뱃지·CTA를 덮어쓴다. (새 카드 append 금지)
- 진행률 표기: `해결됨 X/Y` 형태 유지, 모든 이슈 해결 시 친근한 축하 문구 + “품질 검토로 이동” CTA 노출.
- Proofread 단계 카드(Pinned)와 recap 카드 headline/CTA가 동일해야 한다. 카드 수는 recap 1장 + pinned stage 1장으로 제한.
- 메시지 문구는 2문장을 넘지 않으며, “검토가 끝났어요! 이제 품질 검토를 시작해 볼까요?” 같이 가볍고 긍정적으로 작성한다.

### 아키텍트 관점 확인 사항
- `useChatInsightStore` 큐에 recap insight가 업데이트 가능하도록 replace 메커니즘을 추가한다.
- Proofread state(진행 중, 완료, 오류)를 단일 소스(`ProofreadIssuesContext` 또는 별도 store)로 공유해 UI 간 상태 불일치를 방지한다.
- Monaco 에디터에서 이슈 적용/되돌리기 이벤트가 recap 업데이트 트리거를 호출하도록 이벤트 훅을 확장한다.

### 엔지니어 체크리스트
1. `ProofreadIssuesContext`에 `broadcastRecap()` 함수 추가: 이슈 상태 변화(적용/되돌림/무시/새로고침)마다 호출.
2. `useChatInsightStore`에 `upsert(type: "proofIssueSummary", key: proofreadingId)` API 추가, 기존 메시지 덮어쓰기.
3. `ChatOrchestrator`에서 recap/stage 카드를 **상단 고정(pinned)** 위치에 렌더링하고, 상태가 바뀔 때 텍스트만 업데이트.
4. CTA 누르면 카드가 즉시 업데이트되도록(FE 성공 이벤트 후 recap 재호출) optimistic update 구현.
5. 새 메시지 출력 전 문장 수·길이 검증 util 추가(예: 200자 이상이면 경고 로그).

### 예상 작업 순서
1. 데이터 계층: recap upsert 구현 → 2. UI 계층: recap 카드/Proofread 단계 카드 통합 → 3. Monaco 연동 → 4. QA 시나리오 작성 및 실행.

---

## 2. 사이드바 정보 구조 개편

### 목표
- 헤더/타임라인에 과도하게 노출된 상태 정보를 좌측 사이드바로 이동하여 채팅 영역을 정돈한다.
- 프로젝트 전환 시 사용자의 섹션 열림 상태가 유지되도록 한다.

- 사이드바 기본 구조: (1) 상단 compact 헤더, (2) “워크플로 상태” 아코디언, (3) “빠른 액션” 버튼 스택, (4) “최근 이벤트” 탭.
- 접힌 상태에서도 핵심 진척도(예: “번역 완료 · 경고 3건”)가 한 줄로 나타난다. (아이콘 + 한 줄 텍스트)
- 버튼 액션(원문 업로드/둘러보기 등)은 항상 접근 가능하고, 비활성 시 “원문이 올려지면 활성화돼요”처럼 부드러운 설명을 제공.
- 신참 사용자 전환을 고려해 버튼 라벨은 8자 이내, 보조 설명은 1줄 이하로 유지한다.

### 아키텍트 관점 확인 사항
- UI Store에 `sidebarLayout[projectId]` 구조를 추가해 섹션 접힘 상태·선택 탭을 저장한다.
- “최근 이벤트” 데이터를 `useProjectContext`에서 공유하되, 중복 fetch를 피하도록 캐시 정책을 적용한다.
- 사이드바 모듈화를 위해 새로운 컴포넌트(예: `SidebarWorkflowSection`, `SidebarQuickActions`)를 도입한다.

### 엔지니어 체크리스트
1. `web/src/components/layout/LeftSidebar.tsx` 개편: 상단 요약 + 섹션 컴포넌트 추출.
2. `useUIStore`에 프로젝트별 상태 관리 로직 추가 (`setSidebarSection(projectId, sectionId, open)` 등).
3. 빠른 액션 버튼에 필요한 핸들러(업로드, 둘러보기 등)를 `ChatOrchestrator`에서 호출할 수 있도록 prop drilling 또는 store 연동.
4. “최근 이벤트” 탭 구현: 기존 timeline 데이터 활용, 필요 시 `useWorkflowSummary`로부터 파생.
5. 반응형 레이아웃 확인 (좁은 화면에서 사이드바 hidden → icon으로 진입 가능하게 처리).

### 예상 작업 순서
1. Sidebar 리팩토링 프레임 세팅 → 2. 상태/섹션 분리 구현 → 3. 빠른 액션 재배치 → 4. 타임라인 탭 추가 → 5. QA 및 접근성 테스트.

---

## 3. 온보딩 & 빠른 액션 루프 정비

### UX 관점 확인 사항
- 첫 방문 시 빠른 액션 칩은 사용자가 명시적으로 닫기 전까지 유지되어야 한다.
- 둘러보기/샘플 액션을 한 번 눌러도 다시 돌아올 수 있는 진입점이 남아 있어야 한다(사이드바 버튼 또는 재노출 토글).
- 온보딩 메시지는 과도하게 반복되지 않으며, 상태 변화(원문 업로드 완료 등)에 따라 단계별 안내가 갱신된다.
- 원문 업로드 직후 책 제목과 저자를 입력받는 다이얼로그/폼을 열어 필수 메타데이터를 확보한다. (저장 전까지 다음 단계로 진행되지 않음)

### 아키텍트 관점 확인 사항
- 빠른 액션 상태(`quickReplies`)와 온보딩 플로우(`firstRunScriptShownRef`)를 프로젝트 또는 사용자별로 분리 저장할지 결정한다.
- 투어 모달/가이드가 있다면 글로벌 스토어로 통합해 상태 꼬임을 예방한다.

### 엔지니어 체크리스트
1. `ChatOrchestrator`의 `buildQuickReplies` 로직을 수정하여, 특정 버튼 선택 후에도 목록을 유지하도록 변경.
2. 필요한 경우 “닫기” 버튼을 명시적으로 추가하고, 사용자가 닫았다는 사실을 `localStorage`/store에 기록.
3. 둘러보기/샘플 진입은 사이드바 버튼으로도 접근 가능하게 연결.
4. 원문 업로드 성공 이벤트 후 `collectMetadata` 워크플로를 호출해 책 제목·저자 입력 모달을 띄우고, 저장 시까지 번역 요청을 잠시 보류한다.
5. 온보딩 메시지/추천을 `useWorkflowGuideAgent`와 연동하여 중복 안내를 막는다.

---

## 4. 타임라인·채팅 노이즈 축소

### UX 관점 확인 사항
- 자동 상태 알림(번역 진행 중 등)은 타임라인 섹션에서 먼저 확인할 수 있고, 채팅 메시지는 필요 시(사용자 요청, 오류 발생, 완료 보고)만 추가된다.
- 스테이지 배지를 클릭하면 상단 pinned 카드로 스크롤되고, 추가 메시지는 생성되지 않는다.

### 아키텍트 관점 확인 사항
- `stageNotesRef` 로직을 조정하여, 알림을 chat message보다 recap/stage card에 우선 반영한다.
- 상단에 “현재 상태” 앵커를 두고, 스테이지 클릭 시 해당 앵커로 이동한다.

### 엔지니어 체크리스트
1. `pushAssistant` 호출 중 상태 반복 알림을 필터링하는 guard 추가.
2. recap/스테이지 카드가 항상 메시지 리스트 최상단 또는 고정 위치에 있도록 렌더링 순서를 조정.
3. 스테이지 클릭 시 `scrollToStage`가 recap 카드로 이동하도록 앵커를 재배치.

---

## 5. Proofread 후속 질문 대응

### UX 관점 확인 사항
- 사용자가 “심각 등급만 알려줘”처럼 후속 질문을 하면, LLM 호출 전에 **2문장 이하**의 구조화된 요약으로 응답하고, 보충 설명은 선택적으로 제공한다.
- 응답은 현재 언어 설정과 톤을 유지하며, 경고 수가 많을 때도 겁을 주지 않는 표현(“조금 더 살펴보면 좋겠어요”)을 사용한다.

### 아키텍트 관점 확인 사항
- 간단한 패턴 매칭 또는 intent 라우터 확장을 통해 Proofread 관련 후속 질문을 식별.
- recap 데이터(예: counts, 예시 이슈)를 빠르게 읽을 수 있는 캐시를 `ProofreadIssuesContext` 혹은 글로벌 스토어에 준비.

### 엔지니어 체크리스트
1. `handleMessageAction` 혹은 intent 라우터에 “proofSummaryDetail” 같은 새로운 액션 타입 추가.
2. 요약 응답 생성기는 `translate()`를 사용해 locale-safe한 문자열을 반환.
3. 필요 시 LLM 호출은 fallback으로만 사용하도록 guard.

---

## 6. Ebook 의도 후속 안내

### UX 관점 확인 사항
- 사용자가 전자책 내보내기를 요청하면, 현재 상태(번역/교정 완료 여부)와 다음 행동(예: 메타데이터 입력, 표지 선택)을 명확히 안내한다.
- 사이드바 빠른 액션에도 “전자책 내보내기” 버튼이 존재하며, 조건에 따라 활성/비활성된다.

### 아키텍트 관점 확인 사항
- chat intent 라우터에서 ebook intent 시 `openExportPanel`과 새 follow-up 메시지를 동시에 push.
- 사이드바 버튼과 챗 액션이 동일한 로직을 공유하도록 helper 함수 도입.

### 엔지니어 체크리스트
1. `server/routes/chat.ts` ebook intent 분기에서 상태 요약 메시지를 작성.
2. `SidebarQuickActions`에 ebook 버튼 추가, 기능 조건을 명시.
3. QA: 번역/교정 완료 여부 별 시나리오 검증.

---

- **i18n**: 새로 추가되는 문자열은 `locales/en.json`, `ko.json`에 동시 추가. fallback 영어 텍스트가 남아 있는지 검수.
- **접근성**: 사이드바 아코디언/버튼에 키보드 포커스 & 스크린리더 라벨 제공.
- **성능**: recap upsert가 과도한 리렌더를 만들지 않도록 memoization 적용, insight 큐 처리량 확인.
- **테스트**: E2E 시나리오(온보딩 플로우, 교정 이슈 해결, ebook 흐름)를 Vitest/Playwright 등으로 검증. 카드 수와 문장 수가 규칙을 만족하는지 자동 체크 추가.
- **카피 검수**: 모든 메시지를 제품팀과 리뷰해 어투/길이/위로감이 목표와 맞는지 확인.

## 후속 일정(추천)
1. 설계문서 리뷰 (디자인·PM) – 1일
2. 구현 스프린트 – 1~2주 (항목 1→6 순서 권장)
3. 통합 QA 및 UX 승인 – 2~3일
4. 베타 배포 & 피드백 수집 – 1주

## 실행 마일스톤
| 마일스톤 | 내용 | 예상 기간 |
| --- | --- | --- |
| M1 | Proofread recap/단계 카드 통합, Monaco 이벤트 연동, 문장 길이 검증 util 도입 | 3일 |
| M2 | 사이드바 재구성(헤더·상태·액션·타임라인), 프로젝트별 상태 저장, 빠른 액션 이관 | 4일 |
| M3 | 온보딩/빠른 액션 루프 정비, 사용자가 닫기 전까지 칩 유지, 필수 메타데이터(책 제목·저자) 수집 흐름 구축 | 2일 |
| M4 | 챗 노이즈 필터링, pinned 카드 상단 고정, 스크롤 앵커 개선 | 2일 |
| M5 | Proofread 후속 질문 대응(룰 기반 요약 + LLM fallback), locale 친화 응답 | 3일 |
| M6 | Ebook intent 개선과 사이드바 CTA 연동 | 2일 |
| M7 | 통합 QA, 카피 검수, E2E 테스트, 베타 릴리스 준비 | 2일 |

### 마일스톤 세부 진행 메모

#### M2 잔여 액션
- `LeftSidebar` 재구성 PR에 남겨둔 TODO(프로젝트 전환 시 `useUIStore` hydration) 해결하고, `SidebarHeader` 높이를 64px 이하로 유지한다.
- 빌드 전 `SidebarQuickActions` 내 `aria` 라벨과 포커스 순서를 디자인과 교차 검증한다. (탭 순서: 헤더 → 워크플로 → 빠른 액션 → 최근 활동)
- 상태 저장 로직은 `projectId` 키를 사용해 `sessionStorage`에 보관하고, `SidebarStateAdapter` util로 프론트·백간 key schema를 공유한다.
- QA: 다국어(i18n) 라벨이 잘려 보이지 않는지 확인하고, 1024px 너비 이하에서도 레이아웃이 깨지지 않는지 캡처 수집.

#### M3~M7 연동 체크포인트
- M3 시작 전, 사이드바 CTA 명세를 온보딩 모듈과 공유해 중복 버튼이 없는지 리뷰(오프라인 30분).
- M4에서 채팅 pinned 카드 작업 시, `RightPanel`에서 열리는 엑스트라 탭과 충돌하지 않는지 이벤트 로그를 점검한다.
- M5 룰 기반 요약이 완료되면 `proofSummaryDetail` 인텐트가 사이드바 recap 카드와 동일한 데이터를 참조하는지 통합 테스트 추가.
- M6 이후, 사이드바의 `openExportPanel` CTA와 우측 패널 탭 전환이 동일한 `openExtraTab` 헬퍼를 사용하도록 리팩터링 티켓 생성.
- M7 QA 체크리스트에 접근성(사이드바 단축키, 스크린리더 레이블)과 모바일 뷰 너비 대응을 포함한다.

#### 후속 검증 & 품질 관리
- **Sidebar 검증:** 디자인 팀과 페어 리뷰 세션을 잡아 헤더 간격, 아코디언 전환 애니메이션, 최근 활동 페이징을 실 기기에서 검증한다.
- **RightPanel 조정:** `web/src/components/layout/RightPanel.tsx`의 고정 폭(현재 360px)과 최소/최대 폭 클램프(280~480px)를 재검토해, 사이드바 확장 시 겹침이 발생하지 않도록 한다. 필요 시 `useUIStore`의 `setRightPanelWidth` 기본값을 320px로 조정한다.
- **lint any 정리:** `rg "any" web/src server/src`로 식별한 명시적 `any`를 `unknown` + 타입 내로우잉으로 교체하고, 불가피한 케이스는 주석 대신 `satisfies` 구문으로 안전한 범위만 허용한다. 적용 후 `npm run lint --prefix web` 재검증.

---

## 참고 리소스
- `docs/chat-ux-enhancement-design.md`
- `docs/conversational-editing-plan.md`
- `web/src/context/ProofreadIssuesContext.tsx`
- `web/src/components/chat/ChatOrchestrator.tsx`
- `server/routes/chat.ts`
